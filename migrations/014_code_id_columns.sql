-- Migration 014: Columnas code_id / canonical_code_id (Fase 1.5)
-- Fecha: 2026-01-22
-- Objetivo:
--   - Añadir identidad estable por ID a catalogo_codigos
--   - Preparar transición controlada (dual) sin romper compatibilidad
-- Notas:
--   - Usa BIGINT (identity) para compatibilidad (p.ej. Azure Postgres sin pgcrypto)
--   - Backfill best-effort: canonical_code_id se deriva desde canonical_codigo si existe match

BEGIN;

ALTER TABLE catalogo_codigos
  ADD COLUMN IF NOT EXISTS code_id BIGINT GENERATED BY DEFAULT AS IDENTITY;

ALTER TABLE catalogo_codigos
  ADD COLUMN IF NOT EXISTS canonical_code_id BIGINT;

-- Índices para búsquedas por ID (por proyecto)
CREATE UNIQUE INDEX IF NOT EXISTS ux_catalogo_project_code_id
  ON catalogo_codigos(project_id, code_id)
  WHERE code_id IS NOT NULL;

CREATE INDEX IF NOT EXISTS ix_catalogo_project_canonical_code_id
  ON catalogo_codigos(project_id, canonical_code_id)
  WHERE canonical_code_id IS NOT NULL;

-- 1) Backfill code_id
DO $$
DECLARE
  seq_name TEXT;
BEGIN
  SELECT pg_get_serial_sequence('catalogo_codigos','code_id') INTO seq_name;
  IF seq_name IS NULL THEN
    RAISE EXCEPTION 'No se pudo resolver secuencia para catalogo_codigos.code_id (se requiere IDENTITY/serial)';
  END IF;

  EXECUTE format(
    'UPDATE catalogo_codigos SET code_id = nextval(%L::regclass) WHERE code_id IS NULL',
    seq_name
  );
END $$;

-- 2) Backfill canonical_code_id (regla mínima)
-- 2a) Para activos: canónico es sí mismo
UPDATE catalogo_codigos
   SET canonical_code_id = code_id
 WHERE canonical_code_id IS NULL
   AND status = 'active'
   AND code_id IS NOT NULL;

-- 2b) Para merged/deprecated: intentar resolver por canonical_codigo (best-effort)
UPDATE catalogo_codigos src
   SET canonical_code_id = tgt.code_id
  FROM catalogo_codigos tgt
 WHERE src.project_id = tgt.project_id
   AND src.canonical_code_id IS NULL
   AND src.canonical_codigo IS NOT NULL
   AND tgt.code_id IS NOT NULL
   AND lower(tgt.codigo) = lower(src.canonical_codigo);

COMMIT;
